<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Algorithms Full Notes</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
      background: #f4f7fc;
    }
    header {
      background: #1e88e5;
      color: white;
      text-align: center;
      padding: 1.5rem;
      font-size: 2rem;
    }
    #search {
      display: block;
      margin: 1rem auto;
      padding: 0.7rem;
      width: 90%;
      max-width: 600px;
      font-size: 1rem;
      border-radius: 6px;
      border: 1px solid #ccc;
    }
    .note {
      width: 90%;
      max-width: 900px;
      margin: 1rem auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .note summary {
      padding: 1rem;
      background: #e3f2fd;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.1rem;
    }
    .note div {
      padding: 1rem;
      border-top: 1px solid #ddd;
    }
    ul {
      padding-left: 1.5rem;
    }
  </style>
</head>
<body>
  <header><b>Algorithms</b></header>
  <input type="text" id="search" placeholder="🔍 Search topic..." onkeyup="filterNotes()" />
  <section id="notesContainer">
    <details class="note"><summary>1. Introduction to Algorithms</summary><div>
      A step-by-step procedure to solve a problem. Must be correct, finite, and efficient.
    </div></details><details class="note"><summary>2. Types of Algorithms</summary><div>
  Brute Force, Divide and Conquer, Greedy, Dynamic Programming, Backtracking, Branch and Bound.
</div></details>

<details class="note"><summary>3. Complexity Analysis</summary><div>
  Time & space complexity helps evaluate performance. Time = execution time, Space = memory used.
</div></details>

<details class="note"><summary>4. Big-O Notation</summary><div>
  Describes worst-case performance. O(1), O(log n), O(n), O(n log n), O(n²), etc.
</div></details>

<details class="note"><summary>5. Searching Algorithms</summary><div>
  Linear Search (O(n)), Binary Search (O(log n)) for sorted arrays.
</div></details>

<details class="note"><summary>6. Sorting Algorithms</summary><div>
  Bubble, Selection, Insertion (Simple). Merge, Quick, Heap (Efficient). Tim, Counting, Radix (Special).
</div></details>

<details class="note"><summary>7. Recursion</summary><div>
  Function calls itself to solve subproblems. E.g., Fibonacci, Factorial, Tree traversal.
</div></details>

<details class="note"><summary>8. Divide and Conquer</summary><div>
  Divide → Solve → Combine. E.g., Merge Sort, Quick Sort, Binary Search.
</div></details>

<details class="note"><summary>9. Greedy Algorithms</summary><div>
  Picks best local option at each step. E.g., Huffman coding, Fractional Knapsack.
</div></details>

<details class="note"><summary>10. Dynamic Programming (DP)</summary><div>
  Stores subproblem solutions. E.g., LCS, 0/1 Knapsack, Matrix Chain Multiplication.
</div></details>

<details class="note"><summary>11. Backtracking</summary><div>
  Explore all solutions, backtrack on invalid ones. E.g., N-Queens, Sudoku.
</div></details>

<details class="note"><summary>12. Branch and Bound</summary><div>
  Optimized backtracking using bounds. E.g., TSP, 0/1 Knapsack.
</div></details>

<details class="note"><summary>13. Graph Algorithms</summary><div>
  DFS, BFS, Dijkstra, Bellman-Ford, Kruskal, Prim, Topological Sort.
</div></details>

<details class="note"><summary>14. Shortest Path Algorithms</summary><div>
  Dijkstra (no negatives), Bellman-Ford (negative weights), Floyd-Warshall (all pairs).
</div></details>

<details class="note"><summary>15. Minimum Spanning Tree</summary><div>
  Kruskal’s and Prim’s connect all vertices with min total weight.
</div></details>

<details class="note"><summary>16. String Algorithms</summary><div>
  KMP, Rabin-Karp, Z-Algorithm. Used for pattern matching in text.
</div></details>

<details class="note"><summary>17. Number Theory Algorithms</summary><div>
  Euclidean GCD, Modular Exponentiation, Prime checking. Used in cryptography.
</div></details>

<details class="note"><summary>18. Bit Manipulation</summary><div>
  Efficient operations using bits. E.g., XOR tricks, bit counting.
</div></details>

<details class="note"><summary>19. Sliding Window & Two Pointer</summary><div>
  Solve subarray/string problems efficiently. E.g., max sum, unique substrings.
</div></details>

<details class="note"><summary>20. Trie and Disjoint Set</summary><div>
  Trie: string prefixes. DSU: dynamic connectivity. Used in Kruskal’s algorithm.
</div></details>

<details class="note"><summary>🧠 Study Tips</summary><div>
  <ul>
    <li>Visualize algorithms with animations</li>
    <li>Code from scratch without copy-paste</li>
    <li>Practice on platforms like LeetCode, GFG</li>
    <li>Group similar patterns and solve daily</li>
  </ul>
</div></details>

<details class="note"><summary>📊 Case Study: Google Search</summary><div>
  Uses PageRank (graph), Trie for indexing, Hash Maps for lookup, Greedy + LRU cache for optimization.
</div></details>

  </section>
  <script>
    function filterNotes() {
      const query = document.getElementById("search").value.toLowerCase();
      const notes = document.querySelectorAll(".note");
      notes.forEach(note => {
        note.style.display = note.textContent.toLowerCase().includes(query) ? "block" : "none";
      });
    }
  </script>
</body>
</html>